    # return 0
    # while True:

    #     # after last frame finishes, take new input, then clear and redraw.
    #     i = input("> ").lower()
    #     os.system('clear')

    #     # if the input is the name of a move, have that move be used on the opponent.
    #     if i in player_1.moves:
    #         player_1.moves[i].move(player_1, player_2)
        
        
    #     print_ui(player_1, player_2)
        
    #     if i == "fight":
    #         show_moves(player_1)
    #     elif i == "counter":
    #         print("!!NYI!!")
    #     elif i == "special":
    #         print("!!NYI!!")
    #     elif i == "surrender":
    #         os.system('clear')
    #         print("ok")
    #         return 0
    #     elif i in player_1.moves:
    #         print_menu()
    #     elif i == "":
    #         print_menu()
    #     else:
    #         print_menu()
    #         print(didn't not understand input: "{i}"')



    def parse_input(self, i):
        # TODO: maybe handle parsing inputs outside of the engine. so that it can stand on it's own.
        i = i.lower()
        if i == "fight":
            self.current_submenu = lambda: console_util.show_moves(self.p1)
        elif i == "" or i.lower() == "back":
            self.current_submenu = console_util.print_menu

        elif i in self.p1.moves:

            self.p1_move = self.p1.moves[i].move(self.p1, self.p2, self)
            self.text_queue.append(
                f"{self.p1.name} used {self.p1.moves[i].name}")

            mv = random.choice(list(self.p2.moves.keys()))
            self.p2_move = self.p2.moves[mv].move\
                (self.p2, self.p1, self)
            self.text_queue.append(f"{self.p2.name} used {mv}")

        elif i == "special":
            if self.p1.powered == False:
                self.p1.power_up()
                self.text_queue.append("power")
            else:
                self.text_queue.append("Already MAX POWER")


        if self.p1_move is not None:
            try:
                if self.p2_outcome != SKIP_NEXT_TURN:
                    self.p1_outcome = next(self.p1_move)
            except StopIteration:
                self.p1_move = None
                self.p1_outcome = None

        if self.p1_outcome == WAIT_FOR_OPPONENT:
            move = random.choice(list(self.p2.moves.keys()))
            self.p2_move = self.p2.moves[move].move(self.p2, self.p1, self)
            self.text_queue.append(f"{self.p2.name} used {move}")

        if self.p2_move is not None:
            try:
                self.p2_outcome = next(self.p2_move)
            except StopIteration:
                self.p2_move = None
                self.p2_outcome = None